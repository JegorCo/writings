1. FreeBSD Jail — механизм сhroot, создающий изолированные среды для процессов и сетей внутри одной системы.
2. сgroups от Google — механизм детализированного управления ресурсами, который лёг в основу современных контейнеров.
3. Docker — доминирующая технология в мире контейнеризации и DevOps
4. Сравнеине контейниризации и виртуализации:
5. 

|                                         | Контейнер | Виртуальные машины |
| --------------------------------------- | --------- | ------------------ |
| Изоляция                                | Высокая   | Высокая            |
| Количество ресурсов на запуск           | Низкое    | Среднее            |
| Безопасность                            | Высокая   | Высокая            |
| Запуск другой ОС, отличной от хотстовой | Нет       | Да                 |

cgroups - технология упраления ресурсами системы, который позволяет ограничивать ресурсы системы, с учётом потребностей групп процессов.

## **Основные контроллеры cgroups:**
- **CPU**: конролирует использование процессорного времени. Можно установить лимиты на процент использования CPU или распределять время между группами процессов.
- **Memory**: ограничивает использование оперативной памяти и swap.
- **IO**: контролирует ввод-вывод на блочные устройства.
- **Devices**: управляет доступом к устройствам. Позволяет разрешить или запретить определённым процессам доступ к конкретным устройствам.
- **PIDs**: ограничивает количество процессов в группе.
## **Основные контроллеры namespaces:**
**Namespaces**  - это механизм, который изолирует и виртуализирует системные ресурсы для групп процессов.
- **PID Namespace**: изолирует идентификаторы процессов. Процессы внутри этого пространства видят свои собственные PID, начиная с 1, и не могут видеть процессы вне этого пространства..
- **Mount Namespace**: изолирует точки монтирования файловой системы. Процессы внутри видят собственную файловую систему или её часть, не затрагивая хост-систему.
- **UTS Namespace**: позволяет изолировать имена узлов и доменов, т.е. `hostname` и `domainname`.
- **Network Namespace**: изолирует сетевые интерфейсы, маршруты, таблицы ARP и т.д. Процессы внутри имеют свой собственный сетевой стек.
- **IPC Namespace**: изолирует межпроцессное взаимодействие с помощью System V IPC.
- **User Namespace**: изолирует идентификаторы пользователей и групп.
- **Cgroup Namespace**: иззолирует видимость cgroups. Процессы видят только свои собственные cgroups.
- **Time Namespace**: позволяет изолировать системное время, чтобы процессы могли видеть другое время, нежели хост-система.

## **Концепция разделения серверов Pets vs Cattle**

1. **Pets** - подход, при котором каждый сервер или приложение рассматривается как уникальный и важный элемент инфраструктуры. Подразумевается глубокая настройка каждого элемента, его тщательное обслуживание и внимание к деталям.
2. **Cattle** - подход, при котором серверы и приложения рассматриваются как взаимозаменяемые единицы. Масштабируемость и эффективность вместо уникальности каждого элемента. Акцент на автоматизации процессов управления инфраструктурой и приложениями, чтобы быстро масштабировать и заменять элементы без усилий.

### **Архитектура Docker**
![[Pasted image 20250312151539.png]]
Состоит из:
- **Docker Host**  Физическая или виртуальная машина с установленным Docker Engine, где выполняются контейнеры. Хост служит основой для запуска и управления контейнерами, предоставляя им необходимые ресурсы и среду выполнения.
- **Docker daemon**, или **dockerd** Ядро Docker, служба, которая отвечает на API-вызовы и управляет Docker-объектами: контейнерами, сетями, хранилищами, образами.
- **Docker Image** Шаблон для создания контейнеров, неизменяемый образ, из которого разворачивается контейнер.
- **Dockerfile**  Файл-инструкция для сборки образа.
- **Docker Registry** Репозиторий для хранения и обмена Docker Images.
- **Docker Container** Контейнер, запущенный на базе образа изолированной среды, в которой работает приложение.
- **Docker CLI** Консольная утилита, которая позволяет взаимодействовать с Docker daemon — отправлять ему команды, создавать и управлять Docker-объектами.
### **Основные команды Docker**
- docker run - запустить контейнер
- docker run nginx:1.25 - запустит nginx(даже если его нет)
- docker run -d запустит docker в фоне
- docker ps
- docker container ls
- docker container ps - узнать какие контейнеры запущены
- docker start 90afa06cd4fd запустить контейнер
- docker rm - удалить контейнер
- docker run --publish 8080:80 -d nginx:1.25 - запуск и публикация на порте 8080(хоста) и 80(контейнера) ИЛИ docker run -p 

## **Построение Docker-контейнера**
Описание Docker контейнера содержится в dockerfile 
Пример dockerfile:
`FROM ubuntu:22.04`
`RUN apt-get update && apt-get install -y nginx`
`COPY myapp /usr/share/nginx/html`
`EXPOSE 80`
`CMD ["nginx", "-g", "daemon off;"]`
![[Pasted image 20250319164559.png]]
Данные слои наслаиваются друг на друга, тем самым 
### **Инструкции для DockerFile**

![[Pasted image 20250328180902.png]]
FROM - Указывает образ, с которого начнётся сборка
RUN - выполняет команды сборки контейнера
COPY - копирует файлы 
ADD - добавляет локальные или удалённые файлы и каталоги в образ
ENTYPOINT - исполняемая команда по умолчанию
CMD - команда которая будет выполнена при запуске контейнера
WORKDIR - устанавливает рабочую директорию
ENV - определение переменных окружения
ARG - определение переменных на время сборки(build-time)

### **Инструкция From**
Инструкция `FROM` в Dockerfile определяет базовый образ, который будет использоваться для создания нового образа. Это основная инструкция в Dockerfile. Она указывает на образ, который будет служить основой для всех последующих инструкций.

**Базовый, или родительский, или parent-образ** может быть любым публичным или приватным образом, доступным в реестре образов по умолчанию — Docker Hub — или любом другом реестре образов. Вы можете выбрать любой образ, который соответствует вашим требованиям, и использовать его в качестве отправной точки для создания собственного образа.

Синтаксис инструкции `FROM`:
`FROM <имя_образа>`
`FROM nginx:1.25`

Можно создать базовый образ:
FROM scratch

## Инструкция RUN
Инструкция RUN в Dockerfile используется для выполнения 
`RUN <команда>`
Например
`RUN apt-get update && apt-get install -y nginx`

## Инструкция COPY и ADD
COPY используется для копирования файлов системы хоста в файловую систему контейнера. Это позволяет добавить необходимые файлы и зависимости в образ Docker

`COPY <путь_на_хосте> <путь_в_контейнере>`

`COPY ./src /app/src`

Инструкция ADD схожа по синтаксису и назначению с инструкцию COPY, однако он может скачивать файлы из интернета

`ADD ./file.txt /app/file.txt`

`ADD https://example.com/file.txt /app/file.txt`

`ADD ./archive.tar.gz /app/`

## Инструкция ENTRYPOINT и CMD
Инструкция `ENTRYPOINT` указывает команду, которая будет выполнена при запуске контейнера. Это может быть любая команда внутри контейнера: например, запуск веб-сервера или базы данных.
Инструкция `CMD` используется в качестве аргументов для `ENTRYPOINT` . Итоговая команда запуска контейнера складывается из объединения инструкций `ENTRYPOINT + CMD` .

В следующем примере при запуске контейнера выполнится команда `/usr/bin/python run.py` :

`ENTRYPOINT ["/usr/bin/python"]
`CMD ["run.py"]`

Если `ENTRYPOINT` не задан, то команда запуска в следующем примере будет `/bin/sh/ -c python run.py`:

`CMD ["python", "run.py"]`

ENTRYPOINT - для выбора программы(исполняемый файл)
CMD - команда которая иполняется программой

## Инструкция WORKDIR
Инструкция `WORKDIR` устанавливает рабочий каталог для последующего выполнения инструкций `RUN` , `CMD` , `ENTRYPOINT` , `COPY` и `ADD` . Она создаёт каталог, если он ещё не существует, и сохраняет его в контексте сборки.
`WORKDIR /app/run`
`COPY ./run.py ./run.py`
`ENTRYPOINT ["/usr/bin/python"]`
`CMD ["run.py"]`

## Инструкция ENV
Инструкция `ENV` в Dockerfile нужна для определения переменных окружения. Эти переменные могут использоваться в последующих инструкциях Dockerfile, а также в контейнере, запущенном на основе созданного образа.

`ENV <key>=<value>` 


## Инструкция ARG
Инструкция `ARG` в Dockerfile позволяет задать переменную, значение которой можно передать из командной строки в образ во время его сборки.
Например, можно задать переменную `IMAGE_VER` со значением по умолчанию `1.25` :

```
ARG IMAGE_VER=1.25
FROM nginx:$IMAGE_VER
```

### Версионирование образов
При сборке можно указать название образа и его версию — тег с помощью опции `-t`, `--tag`.

Например, необходимо собрать собственный образ Nginx. Для этого написан Dockerfile:

```
FROM nginx:1.25
COPY index.html /usr/share/nginx/html
```

Для оптимальной сборки необходимо сначала включать медленные операции, затем быстрые операции

### Запуск новой версии контейнера
`docker build -t simple_python_app:v4`

## Container Registry
Имя образа нужно указывать при загрузке в реестре или скачивании из него. Имя может выглядеть так:
- ubuntu:22.04
- library/ubuntu:22.04
- registry-1.docker.io/library/ubuntu:22.04
Прежде чем пулить докер образ на докер хаб необходимо указать тэг 
 ```
 Тег — это произвольный, читаемый идентификатор, который указывает на конкретную версию или вариант образа.
 ```
 
# Источники образов контейнеров

Существуют различные реализации: on-premise-решения развёртывания в инфраструктуре компании, managed-решения, используемые внутри облаков, или публичные Registry, доступные глобально всем пользователям.

Расскажем про самые популярные реализации:

- Docker Hub
- GitHub Container Registry
- Harbor
- Sonatype Nexus Repository

Далее отдельно остановимся на Yandex Container Registry.

## Docker Hub

**Docker Hub поддерживает:**

- **Репозитории, или repositories** Позволяют загружать и скачивать образы контейнеров.
- **Сборки, или builds** Позволяют автоматизировать сборку образов контейнеров из GitHub и Bitbucket, а также загрузку их в Docker Hub.
- **Вебхуки, или webhooks** Запускают действия после успешной загрузки образа в репозиторий для интеграции Docker Hub с другими сервисами.
- **Утилиты командной строки, или Docker Hub CLI** Утилиты и API позволяют взаимодействовать с Docker Hub.
## GitHub Container Registry

GitHub предоставляет свою реализацию Container Registry. Наиболее удобен, если вы храните код в GitHub и используете GitHub Actions для сборки и загрузки образов в реестр.

**Особенности GitHub Container Registry:**

- Сохраняет образы контейнеров в персональном аккаунте или аккаунте организации на GitHub.
- Связывает образ с репозиторием на GitHub.
- Интегрирован с GitHub Actions и позволяет наследовать разрешения от репозитория или задавать гранулярные разрешения на доступ к образу.

## Harbor

Harbor представляет собой реестр образов с открытым исходным кодом, приспособленный для самостоятельного развёртывания в облаках или в собственной инфраструктуре. Подойдёт, если нельзя использовать публичные или managed-решения.

**Возможности Harbor:**

- хранение образов;
- подписывание образов как доверенных;
- сканирование образов на уязвимости;
- поддержка репликаций образов между реестрами;
- управление пользователями;
- контроль доступа к образам;
- аудит активности пользователей.

### Основные команды

`docker image tag` — добавление тегов к образам.
`docker image pull` — скачивание образов из Registry.
`docker image push` — загрузка образов в Registry.

### Микросервис vs монолит
![[Pasted image 20250329184007.png]]
***Минусы микросервисов***

- **Сложность проектирования** Необходимо контролировать и продумывать множество нюансов, таких как количество и размер сервисов, способы управления ими, совместимость API и тому подобное.
- **Высокие затраты на разработку и поддержку** Требуются большие инвестиции в оплату услуг разработчиков, экспертов по внедрению и покупку специализированных инструментов.
- **Проблемы с целостностью данных** Из-за несогласованности модулей продукта возможны ошибки и потери данных.
- **Снижение производительности** Большое количество микросервисов может замедлить работу системы из-за передачи информации между модулями.
# Методология **The Twelve-Factor App**

The Twelve-Factor App или двенадцать факторов приложения, — методология разработки. Зная её, DevOps-инженер может сфокусировать внимание разработчиков на преимуществах микросервисной архитектуры, тем самым повысив эффективность приложения и бизнеса.
![[Pasted image 20250329184216.png]]
Используйте одну кодовую базу. Для этого все исходные файлы приложения должны храниться в репозитории. Разработчикам не разрешается создавать свои собственные репозитории «для удобства», но они могут иметь ветки с личными версиями кодовой базы и деплоить их на тестовые стенды.

